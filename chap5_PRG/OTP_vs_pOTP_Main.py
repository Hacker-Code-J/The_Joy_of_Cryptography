import numpy as np
import matplotlib.pyplot as plt

# Defining a secure Pseudo-Random Generator (PRG) for demonstration purposes.
def G(s):
    # This example PRG will expand a binary input sequence by duplicating each bit.
    # This is, of course, not secure in practice, but serves for illustrative purposes.
    return [bit for bit in s for _ in range(2)]

def query_G():
    lambda_length = 512  # security parameter
    s = np.random.randint(0, 2, lambda_length).tolist()
    return G(s)

def query_random():
    lambda_length = 512  # security parameter
    l_length = 512
    r = np.random.randint(0, 2, lambda_length + l_length).tolist()
    return r

def otp(message, k):
    """
    One-Time Pad XOR function that xors a message with a truly random key 'k'.
    """
    # Convert the message to a binary representation
    message_bin = [int(bit) for bit in format(message, 'b').zfill(len(k))]
    # XOR the message with the key
    return [message_bin[i] ^ k[i] for i in range(len(k))]

def pseudo_otp(message, k):
    """
    Pseudo-OTP XOR function that xors a message with a key 'k' generated by a PRG.
    """
    # Convert the message to a binary representation
    message_bin = [int(bit) for bit in format(message, 'b').zfill(len(k))]
    # XOR the message with the key
    return [message_bin[i] ^ k[i] for i in range(len(k))]

def otp_encrypt_decrypt(message, key):
    """
    Encrypts or decrypts a message using a key with the OTP method.
    The same function can be used for encryption and decryption due to the properties of XOR.
    """
    # Ensure the message is in binary format and the same length as the key
    message_bin = [int(bit) for bit in format(message, 'b').zfill(len(key))]
    # XOR the message with the key
    xor_result = [message_bin[i] ^ key[i] for i in range(len(key))]
    return xor_result

def simulate_encryption(query_function, encrypt_function, num_simulations=1000):
    """
    Simulate the encryption of a large number of messages and count the frequency of 0s and 1s.
    """
    # Initialize counts of 0s and 1s
    bit_counts = {0: 0, 1: 0}
    
    for _ in range(num_simulations):
        # Generate a new key for each message
        key = query_function()
        # Assume the message is a random integer between 0 and 1024 for simplicity
        message = np.random.randint(0, 1024)
        # Encrypt the message
        encrypted_message = encrypt_function(message, key)
        # Count the bits in the encrypted message
        for bit in encrypted_message:
            bit_counts[bit] += 1
    
    return bit_counts

# Run the simulations for both OTP and pseudo-OTP
otp_bit_counts = simulate_encryption(query_random, otp_encrypt_decrypt)
popt_bit_counts = simulate_encryption(query_G, otp_encrypt_decrypt)

# Visualize the results
fig, axs = plt.subplots(1, 2, figsize=(12, 6), sharey=True)

# OTP distribution
axs[0].bar(otp_bit_counts.keys(), otp_bit_counts.values(), color=['blue', 'orange'])
axs[0].set_title('OTP Bit Distribution')
axs[0].set_xlabel('Bit Value')
axs[0].set_ylabel('Frequency')
axs[0].set_xticks([0, 1])
axs[0].set_xticklabels(['0', '1'])

# Pseudo-OTP distribution
axs[1].bar(popt_bit_counts.keys(), popt_bit_counts.values(), color=['blue', 'orange'])
axs[1].set_title('Pseudo-OTP Bit Distribution')
axs[1].set_xlabel('Bit Value')
axs[1].set_xticks([0, 1])
axs[1].set_xticklabels(['0', '1'])

plt.tight_layout()
plt.show()


################################################################################################

# # Example usage with a numeric message (for simplicity we'll use a number instead of a string):
# message = 1345252345  # This is a numeric representation of a message

# # Generate the true random key and the PRG key
# true_random_key = query_random()
# prg_key = query_G()


# def int_to_binstr(integer):
#     """ Convert an integer to a binary string without the '0b' prefix. """
#     return format(integer, 'b')

# def binstr_to_int(bin_str):
#     """ Convert a binary string to an integer. """
#     return int(bin_str, 2)

# # Encrypt the message
# otp_encrypted_message = otp_encrypt_decrypt(message, true_random_key)
# pseudo_otp_encrypted_message = otp_encrypt_decrypt(message, prg_key)

# # Convert the encrypted binary sequence back to integer for easier decryption
# otp_encrypted_message_int = binstr_to_int(''.join(map(str, otp_encrypted_message)))
# pseudo_otp_encrypted_message_int = binstr_to_int(''.join(map(str, pseudo_otp_encrypted_message)))

# # Decrypt the message (using the same function since OTP is symmetric)
# otp_decrypted_message = otp_encrypt_decrypt(otp_encrypted_message_int, true_random_key)
# pseudo_otp_decrypted_message = otp_encrypt_decrypt(pseudo_otp_encrypted_message_int, prg_key)

# # Convert the decrypted binary sequence back to the original message integer
# otp_decrypted_message_int = binstr_to_int(''.join(map(str, otp_decrypted_message)))
# pseudo_otp_decrypted_message_int = binstr_to_int(''.join(map(str, pseudo_otp_decrypted_message)))

# print(f"Message: {message}")
# print(f"----OTP: {otp_decrypted_message_int}")
# print(f"---pOTP: {pseudo_otp_decrypted_message_int}")